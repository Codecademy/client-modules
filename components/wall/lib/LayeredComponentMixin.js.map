{"version":3,"sources":["../src/LayeredComponentMixin.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;2BAekB,cAAc;;;;AAEhC,IAAI,qBAAqB,GAAG;AACxB,mBAAiB,EAAE,6BAAW;;;;AAI5B,QAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;AAC5C,YAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;AACvC,QAAI,CAAC,YAAY,EAAE,CAAC;GACrB;;AAED,oBAAkB,EAAE,8BAAW;AAC7B,QAAI,CAAC,YAAY,EAAE,CAAC;GACrB;;AAED,sBAAoB,EAAE,gCAAW;AAC/B,QAAI,CAAC,cAAc,EAAE,CAAC;AACtB,YAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;GACxC;;AAED,cAAY,EAAE,wBAAW;;;;;;AAMvB,QAAI,YAAY,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC;;;;;AAKtC,QAAI,YAAY,KAAK,IAAI,EAAE;AACzB,+BAAM,MAAM,CAAC,wDAAY,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;KACzC,MAAM;AACL,+BAAM,MAAM,CAAC,YAAY,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;KACzC;;AAED,QAAI,IAAI,CAAC,aAAa,EAAE;AACtB,UAAI,CAAC,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;KACjC;GACF;;AAED,gBAAc,EAAE,0BAAW;AACzB,QAAI,IAAI,CAAC,gBAAgB,EAAE;AACzB,UAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;KACpC;;AAED,6BAAM,sBAAsB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;GAC3C;CACJ,CAAC;;qBAEa,qBAAqB","file":"LayeredComponentMixin.js","sourcesContent":["// taken from https://github.com/Khan/react-components/blob/master/js/layered-component-mixin.jsx\n\n/* Create a new \"layer\" on the page, like a modal or overlay.\n *\n * var LayeredComponent = React.createClass({\n *     mixins: [LayeredComponentMixin],\n *     render: function() {\n *         // render like usual\n *     },\n *     renderLayer: function() {\n *         // render a separate layer (the modal or overlay)\n *     }\n * });\n */\n\nimport React from 'react/addons';\n\nlet LayeredComponentMixin = {\n    componentDidMount: function() {\n      // Appending to the body is easier than managing the z-index of\n      // everything on the page.  It's also better for accessibility and\n      // makes stacking a snap (since components will stack in mount order).\n      this._layer = document.createElement('div');\n      document.body.appendChild(this._layer);\n      this._renderLayer();\n    },\n\n    componentDidUpdate: function() {\n      this._renderLayer();\n    },\n\n    componentWillUnmount: function() {\n      this._unrenderLayer();\n      document.body.removeChild(this._layer);\n    },\n\n    _renderLayer: function() {\n      // By calling this method in componentDidMount() and\n      // componentDidUpdate(), you're effectively creating a \"wormhole\" that\n      // funnels React's hierarchical updates through to a DOM node on an\n      // entirely different part of the page.\n\n      var layerElement = this.renderLayer();\n      // Renders can return null, but React.render() doesn't like being asked\n      // to render null. If we get null back from renderLayer(), just render\n      // a noscript element, like React does when an element's render returns\n      // null.\n      if (layerElement === null) {\n        React.render(<noscript />, this._layer);\n      } else {\n        React.render(layerElement, this._layer);\n      }\n\n      if (this.layerDidMount) {\n        this.layerDidMount(this._layer);\n      }\n    },\n\n    _unrenderLayer: function() {\n      if (this.layerWillUnmount) {\n        this.layerWillUnmount(this._layer);\n      }\n\n      React.unmountComponentAtNode(this._layer);\n    }\n};\n\nexport default LayeredComponentMixin;\n"]}